 unsat:false,
         bo: { v8 -> [1, +oo], v9 -> 0 },
         citv: { v8 -> ≥1, v9 -> =null },
         formula: known=true (no var=var)
                        &&
                        v8 = a1 +1 ∧ v9 = 0
                        &&
                        0=v9∧rand()=v4∧[a1 +1]=v8
                        &&
                        true (no tableau)
                        &&
                        {is_int([v4]) = 1},
                  pruned={[v8] ≠ 0},
                  both=true (no var=var)
                       &&
                       v8 = a2 +1 ∧ v9 = 0
                       &&
                       0=v9∧rand()=v4∧[a2 +1]=v8
                       &&
                       true (no tableau)
                       &&
                       {is_int([v4]) = 1}∧{[v8] ≠ 0}
         { roots={ n$6=v8, &cond=v3, &x=v5 };
           mem  ={ v3 -> { * -> v4 }, v5 -> { * -> v8 } };
           attrs={ v1 -> { MustBeValid(, None, t=0), Uninitialized },
                   v2 -> { MustBeValid(, None, t=0), Uninitialized },
                   v3 -> { MustBeValid(, None, t=0), WrittenTo  },
                   v5 -> { MustBeValid(, None, t=0), WrittenTo  },
                   v8 -> { Allocated,
                           DynamicType ,
                           MustBeValid(, None, t=0),
                           Uninitialized },
                   v9 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
         PRE=[{ roots={ };
                mem  ={ };
                attrs={ };}]
         need_specialization=false
         skipped_calls={ rand -> call to skipped function occurs here }
         Topl={len=0;content=
                [  ]}
         full_trace=5
         6
         7
         8
         9


 set [defined, Return type: void, Formals:  p1:int*, Locals: None]
  [ 0.0s] idle
unsat:false,
  bo: { v3 -> 0 },
  citv: { v3 -> =0 },
  formula: known=true (no var=var)
                 &&
                 v3 = 0
                 &&
                 0=v3∧__infer_skip(0)=v4
                 &&
                 true (no tableau)
                 &&
                 true (no atoms),
           pruned=true (no atoms),
           both=true (no var=var)
                &&
                v3 = 0
                &&
                0=v3∧__infer_skip(0)=v4
                &&
                true (no tableau)
                &&
                true (no atoms)
  { roots={ &return=v5, &p1=v1 };
    mem  ={ v1 -> { * -> v2 }, v2 -> { }, v5 -> { * -> v3 } };
    attrs={ v1 -> { MustBeValid(, None, t=0) },
            v3 -> { Invalid ConstantDereference(is assigned to the null pointer) },
            v5 -> { MustBeValid(, None, t=3), WrittenTo  } };}
  PRE=[{ roots={ &p1=v1 };
         mem  ={ v1 -> { * -> v2 }, v2 -> { } };
         attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
  need_specialization=false
  skipped_calls={ __infer_skip -> call to skipped function occurs here }
  Topl={len=0;content=
         [  ]}
  full_trace=7
  8

   foo [defined, Return type: void, Formals: None, Locals:  x:int* cond:int]
  [ 0.0s] idle
unsat:false,
  bo: { v4 -> [v4, min(0, v4)], v7 -> 0, v9 -> 0 },
  citv: { v4 -> ≤0, v7 -> =null, v9 -> =null },
  formula: known=v7=v9
                 &&
                 v7 = 0 ∧ v9 = 0
                 &&
                 0=v7∧rand()=v4
                 &&
                 true (no tableau)
                 &&
                 {is_int([v4]) = 1},
           pruned={[v4] < 1},
           both=v7=v9
                &&
                v4 = -a8 ∧ v7 = 0 ∧ v9 = 0
                &&
                0=v7∧rand()=v4∧[-a8]=v4
                &&
                true (no tableau)
                &&
                {is_int([v4]) = 1}
  { roots={ };
    mem  ={ v3 -> { * -> v4 }, v5 -> { * -> v7 } };
    attrs={ v1 -> { MustBeValid(, None, t=0), Uninitialized },
            v2 -> { MustBeValid(, None, t=0), Uninitialized },
            v3 -> { s&cond (variable `cond` declared here at line 6 :t1 ) at line 11, column 7,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v5 -> { s&x (variable `x` declared here at line 7 :t5 ) at line 11, column 7,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v7 -> { Invalid ConstantDereference(is assigned to the null pointer) },
            v9 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
  PRE=[{ roots={ };
         mem  ={ };
         attrs={ };}]
  need_specialization=false
  skipped_calls={ rand -> call to skipped function occurs here }
  Topl={len=0;content=
         [  ]}
  full_trace=5
  6
  7
  8
  11

 foo [defined, Return type: void, Formals: None, Locals:  x:int* cond:int]

unsat:false,
  bo: { v4 -> [v4, min(0, v4)], v8 -> [1, +oo], v9 -> 0, v10 -> 0 },
  citv: { v4 -> ≤0, v8 -> ≥1, v9 -> =null, v10 -> =0 },
  formula: known=v9=v10
                 &&
                 v8 = a1 +1 ∧ v9 = 0 ∧ v10 = 0
                 &&
                 0=v9∧rand()=v4∧[a1 +1]=v8
                 &&
                 true (no tableau)
                 &&
                 {is_int([v4]) = 1},
           pruned={[v4] < 1}∧{[v8] ≠ 0},
           both=v9=v10
                &&
                v4 = -a7 ∧ v8 = a2 +1 ∧ v9 = 0 ∧ v10 = 0
                &&
                0=v9∧rand()=v4∧[-a7]=v4∧[a2 +1]=v8
                &&
                true (no tableau)
                &&
                {is_int([v4]) = 1}∧{[v8] ≠ 0}
  { roots={ };
    mem  ={ v3 -> { * -> v4 }, v5 -> { * -> v8 } };
    attrs={ v1 -> { MustBeValid(, None, t=0), Uninitialized },
            v2 -> { MustBeValid(, None, t=0), Uninitialized },
            v3 -> { s&cond (variable `cond` declared here at line 6 :t1 ) at line 11, column 7,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v5 -> { s&x (variable `x` declared here at line 7 :t5 ) at line 11, column 7,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v8 -> { Allocated,
                    DynamicType ,
                    MustBeValid(, None, t=0),
                    Uninitialized,
                    UnreachableAt(line 11, column 7) },
            v9 -> { Invalid ConstantDereference(is assigned to the null pointer) },
            v10 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
  PRE=[{ roots={ };
         mem  ={ };
         attrs={ };}]
  need_specialization=false
  skipped_calls={ __infer_skip -> call to skipped function occurs here,
                  rand -> call to skipped function occurs here }
  Topl={len=0;content=
         [  ]}
  full_trace=5
  6
  7
  8
  9
  11

 foo [defined, Return type: void, Formals: None, Locals:  x:int* cond:int]
Memory Leak

unsat:false,
  bo: { v4 -> [max(1, v4), v4], v7 -> 0, v9 -> 0 },
  citv: { v4 -> ≥1, v7 -> =0, v9 -> =null },
  formula: known=v7=v9
                 &&
                 v7 = 0 ∧ v9 = 0
                 &&
                 0=v7∧rand()=v4
                 &&
                 true (no tableau)
                 &&
                 {is_int([v4]) = 1},
           pruned={1 ≤ [v4]},
           both=v7=v9
                &&
                v4 = a4 +1 ∧ v7 = 0 ∧ v9 = 0
                &&
                0=v7∧rand()=v4∧[a4 +1]=v4
                &&
                true (no tableau)
                &&
                {is_int([v4]) = 1}
  { roots={ };
    mem  ={ v3 -> { * -> v4 }, v5 -> { * -> v7 } };
    attrs={ v1 -> { MustBeValid(, None, t=0), Uninitialized },
            v2 -> { MustBeValid(, None, t=0), Uninitialized },
            v3 -> { s&cond (variable `cond` declared here at line 6 :t1 ) at line 11, column 7,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v5 -> { s&x (variable `x` declared here at line 7 :t5 ) at line 12, column 5,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v7 -> { Invalid ConstantDereference(is assigned to the null pointer) },
            v9 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
  PRE=[{ roots={ };
         mem  ={ };
         attrs={ };}]
  need_specialization=false
  skipped_calls={ rand -> call to skipped function occurs here }
  Topl={len=0;content=
         [  ]}
  full_trace=5
  6
  7
  8
  11
  12

 foo [defined, Return type: void, Formals: None, Locals:  x:int* cond:int]
Memory Leak

unsat:false,
  bo: { v4 -> [max(1, v4), v4], v8 -> [1, +oo], v9 -> 0, v10 -> 0 },
  citv: { v4 -> ≥1, v8 -> ≥1, v9 -> =null, v10 -> =0 },
  formula: known=v9=v10
                 &&
                 v8 = a1 +1 ∧ v9 = 0 ∧ v10 = 0
                 &&
                 0=v9∧rand()=v4∧[a1 +1]=v8
                 &&
                 true (no tableau)
                 &&
                 {is_int([v4]) = 1},
           pruned={1 ≤ [v4]}∧{[v8] ≠ 0},
           both=v9=v10
                &&
                v4 = a3 +1 ∧ v8 = a2 +1 ∧ v9 = 0 ∧ v10 = 0
                &&
                0=v9∧rand()=v4∧[a2 +1]=v8∧[a3 +1]=v4
                &&
                true (no tableau)
                &&
                {is_int([v4]) = 1}∧{[v8] ≠ 0}
  { roots={ };
    mem  ={ v3 -> { * -> v4 }, v5 -> { * -> v8 } };
    attrs={ v1 -> { MustBeValid(, None, t=0), Uninitialized },
            v2 -> { MustBeValid(, None, t=0), Uninitialized },
            v3 -> { s&cond (variable `cond` declared here at line 6 :t1 ) at line 11, column 7,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v5 -> { s&x (variable `x` declared here at line 7 :t5 ) at line 12, column 5,
                    MustBeValid(, None, t=0),
                    WrittenTo  },
            v8 -> { DynamicType ,
                    Invalid CFree(was invalidated by call to `free()`) },
            v9 -> { Invalid ConstantDereference(is assigned to the null pointer) },
            v10 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
  PRE=[{ roots={ };
         mem  ={ };
         attrs={ };}]
  need_specialization=false
  skipped_calls={ __infer_skip -> call to skipped function occurs here,
                  rand -> call to skipped function occurs here }
  Topl={len=0;content=
         [  ]}
  full_trace=5
  6
  7
  8
  9
  11
  12