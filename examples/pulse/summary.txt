 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
{LatentInvalidAccess(ptr) unsat:false,
                          bo: { v2 -> [max(0, v2), min(0, v2)], v3 -> 123 },
                          citv: { v2 -> =0, v3 -> =123 },
                          formula: known=true (no var=var)
                                         &&
                                         v3 = 123
                                         &&
                                         123=v3
                                         &&
                                         true (no tableau)
                                         &&
                                         true (no atoms),
                                   pruned={[v2] = 0},
                                   both=true (no var=var)
                                        &&
                                        v2 = 0 ∧ v3 = 123
                                        &&
                                        0=v2∧123=v3
                                        &&
                                        true (no tableau)
                                        &&
                                        true (no atoms)
                          { roots={ &ptr=v1 };
                            mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                            attrs={ v1 -> { MustBeValid(, None, t=0) },
                                    v2 -> { ISLAbduced , WrittenTo  },
                                    v3 -> { Invalid ConstantDereference(is assigned to the constant 123) } };}
                          PRE=[{ roots={ &ptr=v1 };
                                 mem  ={ v1 -> { * -> v2 } };
                                 attrs={ v1 -> { MustBeInitialized(, t=0),
                                                 MustBeValid(, None, t=0) },
                                         v2 -> { ISLAbduced ,
                                                 MustBeValid(, None, t=2) } };}]
                          need_specialization=false
                          skipped_calls={ }
                          Topl={len=0;content=
                                 [  ]}
                          full_trace=16
                          17
                          18}

 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
unsat:false,
bo: { v2 -> [1, +oo], v3 -> 123 },
citv: { v2 -> ≥1, v3 -> =123 },
formula: known=true (no var=var)
               &&
               v2 = a1 +1 ∧ v3 = 123
               &&
               123=v3∧[a1 +1]=v2
               &&
               true (no tableau)
               &&
               true (no atoms),
         pruned=true (no atoms),
         both=true (no var=var)
              &&
              v2 = a2 +1 ∧ v3 = 123
              &&
              123=v3∧[a2 +1]=v2
              &&
              true (no tableau)
              &&
              true (no atoms)
{ roots={ &ptr=v1 };
  mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { Invalid CFree(was invalidated by call to `free()`),
                  WrittenTo  },
          v3 -> { Invalid ConstantDereference(is assigned to the constant 123) } };}
PRE=[{ roots={ &ptr=v1 };
       mem  ={ v1 -> { * -> v2 }, v2 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
               v2 -> { ISLAbduced , MustBeValid(, None, t=2) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=16
17
18

 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
{ISLLatentMemoryError unsat:false,
                      bo: { },
                      citv: { },
                      formula: known=true (no var=var)
                                     &&
                                     true (no linear)
                                     &&
                                     true (no term_eqs)
                                     &&
                                     true (no tableau)
                                     &&
                                     true (no atoms),
                               pruned=true (no atoms),
                               both=true (no var=var)
                                    &&
                                    true (no linear)
                                    &&
                                    true (no term_eqs)
                                    &&
                                    true (no tableau)
                                    &&
                                    true (no atoms)
                      { roots={ &ptr=v1 };
                        mem  ={ v1 -> { * -> v2 } };
                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                v2 -> { Invalid CFree(was invalidated by call to `free()`) } };}
                      PRE=[{ roots={ &ptr=v1 };
                             mem  ={ v1 -> { * -> v2 } };
                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                             MustBeValid(, None, t=0) },
                                     v2 -> { Invalid CFree(was invalidated by call to `free()`) } };}]
                      need_specialization=false
                      skipped_calls={ }
                      Topl={len=0;content=
                             [  ]}
                      full_trace=16
                      17}

 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
{ISLLatentMemoryError unsat:false,
                      bo: { },
                      citv: { },
                      formula: known=true (no var=var)
                                     &&
                                     true (no linear)
                                     &&
                                     true (no term_eqs)
                                     &&
                                     true (no tableau)
                                     &&
                                     true (no atoms),
                               pruned=true (no atoms),
                               both=true (no var=var)
                                    &&
                                    true (no linear)
                                    &&
                                    true (no term_eqs)
                                    &&
                                    true (no tableau)
                                    &&
                                    true (no atoms)
                      { roots={ &ptr=v1 };
                        mem  ={ v1 -> { * -> v2 } };
                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                v2 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
                      PRE=[{ roots={ &ptr=v1 };
                             mem  ={ v1 -> { * -> v2 } };
                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                             MustBeValid(, None, t=0) },
                                     v2 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}]
                      need_specialization=false
                      skipped_calls={ }
                      Topl={len=0;content=
                             [  ]}
                      full_trace=16
                      17}

 vendor [defined, Return type: int*, Formals:  value:int, Locals:  ptr:int*]
unsat:false,
bo: { v3 -> [v3, min(0, v3)], v4 -> 0, v8 -> 0 },
citv: { v3 -> ≤0, v4 -> =null, v8 -> =null },
formula: known=v4=v8
               &&
               v4 = 0
               &&
               0=v8
               &&
               true (no tableau)
               &&
               {is_int([v3]) = 1},
         pruned={[v3] ≤ 0},
         both=v4=v8
              &&
              v3 = -a2 ∧ v4 = 0
              &&
              0=v8∧[-a2]=v3
              &&
              true (no tableau)
              &&
              {is_int([v3]) = 1}
{ roots={ &value=v1, &return=v12 };
  mem  ={ v1 -> { * -> v3 }, v6 -> { * -> v4 }, v12 -> { * -> v4 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { MustBeValid(, None, t=0), Uninitialized },
          v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
          v6 -> { s&ptr (variable `ptr` declared here at line 8 :t6 ) at line 12, column 12,
                  MustBeValid(, None, t=0),
                  WrittenTo  },
          v12 -> { MustBeValid(, None, t=18), WrittenTo  } };}
PRE=[{ roots={ &value=v1 };
       mem  ={ v1 -> { * -> v3 }, v3 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=4
5
8
9
12

 vendor [defined, Return type: int*, Formals:  value:int, Locals:  ptr:int*]
unsat:false,
bo: { v3 -> [v3, min(0, v3)], v4 -> 0, v9 -> [1, +oo], v10 -> 10 },
citv: { v3 -> ≤0, v4 -> =null, v9 -> ≥1, v10 -> =10 },
formula: known=true (no var=var)
               &&
               v4 = 0 ∧ v9 = a3 +1 ∧ v10 = 10
               &&
               0=v4∧10=v10∧[a3 +1]=v9
               &&
               true (no tableau)
               &&
               {is_int([v3]) = 1},
         pruned={[v3] ≤ 0}∧{[v9] ≠ 0},
         both=true (no var=var)
              &&
              v3 = -a2 ∧ v4 = 0 ∧ v9 = a4 +1 ∧ v10 = 10
              &&
              0=v4∧10=v10∧[-a2]=v3∧[a4 +1]=v9
              &&
              true (no tableau)
              &&
              {is_int([v3]) = 1}∧{[v9] ≠ 0}
{ roots={ &value=v1, &return=v11 };
  mem  ={ v1 -> { * -> v3 },
          v6 -> { * -> v9 },
          v9 -> { * -> v10 },
          v11 -> { * -> v9 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { MustBeValid(, None, t=0), Uninitialized },
          v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
          v6 -> { s&ptr (variable `ptr` declared here at line 8 :t6 ) at line 12, column 12,
                  MustBeValid(, None, t=0),
                  WrittenTo  },
          v9 -> { Allocated,
                  DynamicType ,
                  MustBeValid(, None, t=0),
                  WrittenTo  },
          v10 -> { Invalid ConstantDereference(is assigned to the constant 10) },
          v11 -> { MustBeValid(, None, t=21), WrittenTo  } };}
PRE=[{ roots={ &value=v1 };
       mem  ={ v1 -> { * -> v3 }, v3 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=4
5
8
9
10
12

 vendor [defined, Return type: int*, Formals:  value:int, Locals:  ptr:int*]
unsat:false,
bo: { v3 -> [max(1, v3), v3], v4 -> 0 },
citv: { v3 -> ≥1, v4 -> =null },
formula: known=true (no var=var)
               &&
               v4 = 0
               &&
               0=v4
               &&
               true (no tableau)
               &&
               {is_int([v3]) = 1},
         pruned={0 < [v3]},
         both=true (no var=var)
              &&
              v3 = a1 +1 ∧ v4 = 0
              &&
              0=v4∧[a1 +1]=v3
              &&
              true (no tableau)
              &&
              {is_int([v3]) = 1}
{ roots={ &value=v1, &return=v5 };
  mem  ={ v1 -> { * -> v3 }, v5 -> { * -> v4 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { s&ptr (variable `ptr` declared here at line 4 :t0 ) at line 14, column 1,
                  MustBeValid(, None, t=0),
                  Uninitialized },
          v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
          v5 -> { MustBeValid(, None, t=6), WrittenTo  } };}
PRE=[{ roots={ &value=v1 };
       mem  ={ v1 -> { * -> v3 }, v3 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=4
5
6

 client0 [defined, Return type: int, Formals: None, Locals:  ptr:int*]
Null Dereference
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ }
              Topl={len=0;content=
                     [  ]}
              full_trace=21
              22
              23}

 main [defined, Return type: int, Formals: None, Locals:  p:int* x:int]
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ rand -> call to skipped function occurs here }
              Topl={len=0;content=
                     [  ]}
              full_trace=27
              29
              31}

 main [defined, Return type: int, Formals: None, Locals:  p:int* x:int]
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ rand -> call to skipped function occurs here }
              Topl={len=0;content=
                     [  ]}
              full_trace=27
              29
              31}

 main [defined, Return type: int, Formals: None, Locals:  p:int* x:int]
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ rand -> call to skipped function occurs here }
              Topl={len=0;content=
                     [  ]}
              full_trace=27
              29
              31} client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
{LatentInvalidAccess(ptr) unsat:false,
                          bo: { v2 -> [max(0, v2), min(0, v2)], v3 -> 123 },
                          citv: { v2 -> =0, v3 -> =123 },
                          formula: known=true (no var=var)
                                         &&
                                         v3 = 123
                                         &&
                                         123=v3
                                         &&
                                         true (no tableau)
                                         &&
                                         true (no atoms),
                                   pruned={[v2] = 0},
                                   both=true (no var=var)
                                        &&
                                        v2 = 0 ∧ v3 = 123
                                        &&
                                        0=v2∧123=v3
                                        &&
                                        true (no tableau)
                                        &&
                                        true (no atoms)
                          { roots={ &ptr=v1 };
                            mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                            attrs={ v1 -> { MustBeValid(, None, t=0) },
                                    v2 -> { ISLAbduced , WrittenTo  },
                                    v3 -> { Invalid ConstantDereference(is assigned to the constant 123) } };}
                          PRE=[{ roots={ &ptr=v1 };
                                 mem  ={ v1 -> { * -> v2 } };
                                 attrs={ v1 -> { MustBeInitialized(, t=0),
                                                 MustBeValid(, None, t=0) },
                                         v2 -> { ISLAbduced ,
                                                 MustBeValid(, None, t=2) } };}]
                          need_specialization=false
                          skipped_calls={ }
                          Topl={len=0;content=
                                 [  ]}
                          full_trace=16
                          17
                          18}

 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
unsat:false,
bo: { v2 -> [1, +oo], v3 -> 123 },
citv: { v2 -> ≥1, v3 -> =123 },
formula: known=true (no var=var)
               &&
               v2 = a1 +1 ∧ v3 = 123
               &&
               123=v3∧[a1 +1]=v2
               &&
               true (no tableau)
               &&
               true (no atoms),
         pruned=true (no atoms),
         both=true (no var=var)
              &&
              v2 = a2 +1 ∧ v3 = 123
              &&
              123=v3∧[a2 +1]=v2
              &&
              true (no tableau)
              &&
              true (no atoms)
{ roots={ &ptr=v1 };
  mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { Invalid CFree(was invalidated by call to `free()`),
                  WrittenTo  },
          v3 -> { Invalid ConstantDereference(is assigned to the constant 123) } };}
PRE=[{ roots={ &ptr=v1 };
       mem  ={ v1 -> { * -> v2 }, v2 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
               v2 -> { ISLAbduced , MustBeValid(, None, t=2) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=16
17
18

 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
{ISLLatentMemoryError unsat:false,
                      bo: { },
                      citv: { },
                      formula: known=true (no var=var)
                                     &&
                                     true (no linear)
                                     &&
                                     true (no term_eqs)
                                     &&
                                     true (no tableau)
                                     &&
                                     true (no atoms),
                               pruned=true (no atoms),
                               both=true (no var=var)
                                    &&
                                    true (no linear)
                                    &&
                                    true (no term_eqs)
                                    &&
                                    true (no tableau)
                                    &&
                                    true (no atoms)
                      { roots={ &ptr=v1 };
                        mem  ={ v1 -> { * -> v2 } };
                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                v2 -> { Invalid CFree(was invalidated by call to `free()`) } };}
                      PRE=[{ roots={ &ptr=v1 };
                             mem  ={ v1 -> { * -> v2 } };
                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                             MustBeValid(, None, t=0) },
                                     v2 -> { Invalid CFree(was invalidated by call to `free()`) } };}]
                      need_specialization=false
                      skipped_calls={ }
                      Topl={len=0;content=
                             [  ]}
                      full_trace=16
                      17}

 client [defined, Return type: int, Formals:  ptr:int*, Locals: None]
{ISLLatentMemoryError unsat:false,
                      bo: { },
                      citv: { },
                      formula: known=true (no var=var)
                                     &&
                                     true (no linear)
                                     &&
                                     true (no term_eqs)
                                     &&
                                     true (no tableau)
                                     &&
                                     true (no atoms),
                               pruned=true (no atoms),
                               both=true (no var=var)
                                    &&
                                    true (no linear)
                                    &&
                                    true (no term_eqs)
                                    &&
                                    true (no tableau)
                                    &&
                                    true (no atoms)
                      { roots={ &ptr=v1 };
                        mem  ={ v1 -> { * -> v2 } };
                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                v2 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}
                      PRE=[{ roots={ &ptr=v1 };
                             mem  ={ v1 -> { * -> v2 } };
                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                             MustBeValid(, None, t=0) },
                                     v2 -> { Invalid ConstantDereference(is assigned to the null pointer) } };}]
                      need_specialization=false
                      skipped_calls={ }
                      Topl={len=0;content=
                             [  ]}
                      full_trace=16
                      17}

 vendor [defined, Return type: int*, Formals:  value:int, Locals:  ptr:int*]
unsat:false,
bo: { v3 -> [v3, min(0, v3)], v4 -> 0, v8 -> 0 },
citv: { v3 -> ≤0, v4 -> =null, v8 -> =null },
formula: known=v4=v8
               &&
               v4 = 0
               &&
               0=v8
               &&
               true (no tableau)
               &&
               {is_int([v3]) = 1},
         pruned={[v3] ≤ 0},
         both=v4=v8
              &&
              v3 = -a2 ∧ v4 = 0
              &&
              0=v8∧[-a2]=v3
              &&
              true (no tableau)
              &&
              {is_int([v3]) = 1}
{ roots={ &value=v1, &return=v12 };
  mem  ={ v1 -> { * -> v3 }, v6 -> { * -> v4 }, v12 -> { * -> v4 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { MustBeValid(, None, t=0), Uninitialized },
          v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
          v6 -> { s&ptr (variable `ptr` declared here at line 8 :t6 ) at line 12, column 12,
                  MustBeValid(, None, t=0),
                  WrittenTo  },
          v12 -> { MustBeValid(, None, t=18), WrittenTo  } };}
PRE=[{ roots={ &value=v1 };
       mem  ={ v1 -> { * -> v3 }, v3 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=4
5
8
9
12

 vendor [defined, Return type: int*, Formals:  value:int, Locals:  ptr:int*]
unsat:false,
bo: { v3 -> [v3, min(0, v3)], v4 -> 0, v9 -> [1, +oo], v10 -> 10 },
citv: { v3 -> ≤0, v4 -> =null, v9 -> ≥1, v10 -> =10 },
formula: known=true (no var=var)
               &&
               v4 = 0 ∧ v9 = a3 +1 ∧ v10 = 10
               &&
               0=v4∧10=v10∧[a3 +1]=v9
               &&
               true (no tableau)
               &&
               {is_int([v3]) = 1},
         pruned={[v3] ≤ 0}∧{[v9] ≠ 0},
         both=true (no var=var)
              &&
              v3 = -a2 ∧ v4 = 0 ∧ v9 = a4 +1 ∧ v10 = 10
              &&
              0=v4∧10=v10∧[-a2]=v3∧[a4 +1]=v9
              &&
              true (no tableau)
              &&
              {is_int([v3]) = 1}∧{[v9] ≠ 0}
{ roots={ &value=v1, &return=v11 };
  mem  ={ v1 -> { * -> v3 },
          v6 -> { * -> v9 },
          v9 -> { * -> v10 },
          v11 -> { * -> v9 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { MustBeValid(, None, t=0), Uninitialized },
          v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
          v6 -> { s&ptr (variable `ptr` declared here at line 8 :t6 ) at line 12, column 12,
                  MustBeValid(, None, t=0),
                  WrittenTo  },
          v9 -> { Allocated,
                  DynamicType ,
                  MustBeValid(, None, t=0),
                  WrittenTo  },
          v10 -> { Invalid ConstantDereference(is assigned to the constant 10) },
          v11 -> { MustBeValid(, None, t=21), WrittenTo  } };}
PRE=[{ roots={ &value=v1 };
       mem  ={ v1 -> { * -> v3 }, v3 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=4
5
8
9
10
12

 vendor [defined, Return type: int*, Formals:  value:int, Locals:  ptr:int*]
unsat:false,
bo: { v3 -> [max(1, v3), v3], v4 -> 0 },
citv: { v3 -> ≥1, v4 -> =null },
formula: known=true (no var=var)
               &&
               v4 = 0
               &&
               0=v4
               &&
               true (no tableau)
               &&
               {is_int([v3]) = 1},
         pruned={0 < [v3]},
         both=true (no var=var)
              &&
              v3 = a1 +1 ∧ v4 = 0
              &&
              0=v4∧[a1 +1]=v3
              &&
              true (no tableau)
              &&
              {is_int([v3]) = 1}
{ roots={ &value=v1, &return=v5 };
  mem  ={ v1 -> { * -> v3 }, v5 -> { * -> v4 } };
  attrs={ v1 -> { MustBeValid(, None, t=0) },
          v2 -> { s&ptr (variable `ptr` declared here at line 4 :t0 ) at line 14, column 1,
                  MustBeValid(, None, t=0),
                  Uninitialized },
          v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
          v5 -> { MustBeValid(, None, t=6), WrittenTo  } };}
PRE=[{ roots={ &value=v1 };
       mem  ={ v1 -> { * -> v3 }, v3 -> { } };
       attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
need_specialization=false
skipped_calls={ }
Topl={len=0;content=
       [  ]}
full_trace=4
5
6

 client0 [defined, Return type: int, Formals: None, Locals:  ptr:int*]
Null Dereference
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ }
              Topl={len=0;content=
                     [  ]}
              full_trace=21
              22
              23}

 main [defined, Return type: int, Formals: None, Locals:  p:int* x:int]
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ rand -> call to skipped function occurs here }
              Topl={len=0;content=
                     [  ]}
              full_trace=27
              29
              31}

 main [defined, Return type: int, Formals: None, Locals:  p:int* x:int]
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ rand -> call to skipped function occurs here }
              Topl={len=0;content=
                     [  ]}
              full_trace=27
              29
              31}

 main [defined, Return type: int, Formals: None, Locals:  p:int* x:int]
{AbortProgram unsat:false,
              bo: { },
              citv: { },
              formula: known=true (no var=var)
                             &&
                             true (no linear)
                             &&
                             true (no term_eqs)
                             &&
                             true (no tableau)
                             &&
                             true (no atoms),
                       pruned=true (no atoms),
                       both=true (no var=var)
                            &&
                            true (no linear)
                            &&
                            true (no term_eqs)
                            &&
                            true (no tableau)
                            &&
                            true (no atoms)
              { roots={ };
                mem  ={ };
                attrs={ };}
              PRE=[{ roots={ };
                     mem  ={ };
                     attrs={ };}]
              need_specialization=false
              skipped_calls={ rand -> call to skipped function occurs here }
              Topl={len=0;content=
                     [  ]}
              full_trace=27
              29
              31}